@startuml
title CollectionTask创建与配置同步时序图 (Deployment常驻Worker架构)

skinparam backgroundColor #FFFFFF
skinparam sequenceMessageAlign center
skinparam responseMessageBelowArrow true

actor User as user
participant "Web UI\n(Management Plane)" as ui
participant "K8s API Server" as apiserver
participant "Operator\nController" as operator
participant "CollectionTask\nCR" as cr
database "PostgreSQL\nControl Center" as controldb
participant "Worker Pod\n(Deployment)" as worker

autonumber

== CR创建阶段 ==

user -> ui: 填写任务配置\n(名称、数据源、采集规则等)
note right of user
  配置内容：
  - 任务名称: "每日医药资讯采集"
  - Collector类型: web-rpa
  - 数据源: https://example.com
  - Cron: "0 8 * * *" (每天8点)
  - 解析规则: XPath/CSS选择器
  - 存储配置: 目标PostgreSQL库
end note

ui -> ui: 前端验证(必填项、格式等)
ui -> ui: Cron表达式可视化预览

user -> ui: 点击"创建任务"

ui -> apiserver: POST /apis/datafusion.io/v1/namespaces/default/collectiontasks\n{CR YAML}
activate apiserver

apiserver -> apiserver: 验证CR Schema
apiserver -> apiserver: RBAC权限检查

alt CR验证失败
    apiserver --> ui: 400 Bad Request\n{error: "Invalid CR spec"}
    ui --> user: "配置验证失败"
    note right: 提前终止流程
end

apiserver -> apiserver: 持久化CR到etcd

apiserver -> cr: 创建CR对象
activate cr
cr --> apiserver: CR已创建\n{uid, generation=1}
deactivate cr

apiserver --> ui: 201 Created\n{metadata: {uid, name, ...}}
deactivate apiserver

ui --> user: 显示创建成功\n"任务已创建，等待调度..."

== Operator监听与同步阶段 ==

operator -> operator: Watch事件触发\n(Add CollectionTask)
activate operator

operator -> apiserver: Get CollectionTask CR
activate apiserver
apiserver --> operator: CR详细信息\n{spec, metadata}
deactivate apiserver

operator -> operator: 验证CR配置完整性
operator -> operator: 解析Cron表达式
operator -> operator: 计算next_run_time

== 配置同步到PostgreSQL ==

operator -> controldb: BEGIN TRANSACTION
activate controldb

operator -> controldb: INSERT INTO collection_tasks\n(cr_uid, task_name, collector_type,\ncollector_config, parsing_rules,\ncleaning_rules, cron_schedule,\nnext_run_time, enabled=true,\ncreated_at=NOW())
note right of controldb
  表字段映射:
  - cr_uid: CR的metadata.uid
  - task_name: CR的metadata.name
  - collector_type: spec.collectorType
  - collector_config: spec.dataSource (JSON)
  - parsing_rules: spec.processor (JSON)
  - cron_schedule: spec.schedule
  - next_run_time: 根据Cron计算
  - enabled: 基于spec.suspended反转
end note
controldb --> operator: OK (task_id=123)

operator -> controldb: COMMIT TRANSACTION
controldb --> operator: Transaction Committed
deactivate controldb

== 更新CR Status ==

operator -> apiserver: Update CR.Status.Phase = "Active"
activate apiserver
operator -> apiserver: Update CR.Status.Conditions
operator -> apiserver: Update CR.Status.ObservedGeneration = 1
apiserver --> operator: Status Updated
deactivate apiserver

operator -> operator: Requeue after 1 minute
deactivate operator

note right of operator
  Reconcile完成:
  - CR配置已同步到PostgreSQL
  - Worker可以轮询获取任务
  - 状态回传机制激活
end note

== Worker轮询与执行 ==

worker -> worker: 定时器触发(每30秒)
activate worker

worker -> controldb: SELECT * FROM collection_tasks\nWHERE enabled=true\nAND collector_type='web-rpa'\nAND next_run_time <= NOW()\nFOR UPDATE SKIP LOCKED\nLIMIT 1
activate controldb

note right of controldb
  分布式锁机制:
  - FOR UPDATE SKIP LOCKED
  - 多个Worker并发查询
  - 只有一个Worker获取锁
  - 避免重复执行
end note

controldb --> worker: 返回待执行任务\n{task_id=123, cr_uid, collector_config, ...}
deactivate controldb

worker -> controldb: BEGIN TRANSACTION
activate controldb

worker -> controldb: INSERT INTO task_executions\n(id, cr_uid, task_id,\nstatus='running',\nstart_time=NOW(),\nworker_pod='{POD_NAME}')
controldb --> worker: execution_id

worker -> controldb: UPDATE collection_tasks\nSET next_run_time = calculate_next(cron),\nlast_run_at = NOW()\nWHERE task_id = 123
controldb --> worker: OK

worker -> controldb: COMMIT TRANSACTION
controldb --> worker: Transaction Committed
deactivate controldb

worker -> worker: 执行采集任务...\n(浏览器池/HTTP连接池)
deactivate worker

note right of worker
  Worker执行流程:
  1. 从资源池获取实例(浏览器/连接)
  2. 执行数据采集
  3. 数据处理(解析/清洗)
  4. 存储到目标库
  5. 更新task_executions状态
end note

== 状态回传到CR ==

operator -> operator: 定时Reconcile触发\n(每1分钟)
activate operator

operator -> controldb: SELECT * FROM task_executions\nWHERE cr_uid = '{uid}'\nORDER BY start_time DESC LIMIT 1
activate controldb
controldb --> operator: 最新执行记录\n{status='success', records_stored=150, ...}
deactivate controldb

operator -> apiserver: Update CR.Status.LastScheduleTime
activate apiserver
operator -> apiserver: Update CR.Status.LastSuccessTime
operator -> apiserver: Update CR.Status.LastExecutionSummary
apiserver --> operator: Status Updated
deactivate apiserver

operator -> operator: Requeue after 1 minute
deactivate operator

ui -> apiserver: 定期查询CR状态\n(Watch或Polling)
activate apiserver
apiserver --> ui: CR最新状态\n{status: {lastSuccessTime, ...}}
deactivate apiserver

ui -> ui: 刷新任务列表
ui --> user: 显示任务执行状态\n"最近执行: 2025-01-27 08:00 (成功, 150条记录)"

@enduml
